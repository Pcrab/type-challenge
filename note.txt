898-includes
infer,  extends, readonly
// explain Expect
https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

type Equals<X, Y> =
    (<T>() => T extends X ? 1 : 2) extends
    (<T>() => T extends Y ? 1 : 2) ? true : false;

会检查是否所有类型都满足既能赋值给X，也能赋值给Y

type Equals<X, Y> = X extends Y ? Y extends X ? true : false : false;

只会检查是否 X 能赋值给 Y 且 Y 能赋值给 X，在部分情况下会出现错误

3312-parameters
(...args: any[]) => any 应当写成 (...args: never[]) => unknown
需要使用者明确指定类型的时候用 unknown
不需要知道这是什么类型的时候用 never

3-omit
https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as
使用 as 来 remap key

9-deep-readonly
https://stackoverflow.com/questions/68693054/what-is-extends-never-used-for/68693367
extends never 指找不到任何确定的 key 的情况
因此 {a: string} | {b: string} 也没有确定的 key，会继承 never

12-chainable-options
题目挺好，result3 又要有 type-error 又要通过不太合理

20-promise-all
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types
https://github.com/microsoft/TypeScript/pull/39094
{
    [key in keyof T]: T[key]
}
也可以用于数组类型！

110-capitalize
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#extends-constraints-on-infer-type-variables
infer 在 ts 4.7 中被增强了，可以在之后使用 extends

191-append-arguments
关于用到的 “any function” 类型 (...args: never[]): unknown
https://www.reddit.com/r/typescript/comments/muyl55/understanding_args_never_in_typescript_handbook/?rdt=35546

296-permutation
Distributive Conditional Types
对 conditional types 使用 extend 后，会变成对每一种可能性都进行一次判断，最后将结果联合

527-append-to-object
https://github.com/type-challenges/type-challenges/issues/9115
不可以使用 & 来合并。
通常情况下合并得到的类型不会有问题，但如果提供的 key 是一个已有的 key，而提供的对应类型与原有类型不同，& 无法推导出交集，因此会得到 never。
utils 里的 Equal 需要在任何时候两个类型都完全相等才行，因此会报错。
